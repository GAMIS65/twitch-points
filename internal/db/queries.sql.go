// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRedemption = `-- name: CreateRedemption :one
INSERT INTO redemptions (message_id, streamer_id, viewer_id)
VALUES ($1, $2, $3)
RETURNING message_id, streamer_id, viewer_id, redeemed_at
`

type CreateRedemptionParams struct {
	MessageID  string      `json:"message_id"`
	StreamerID pgtype.Text `json:"streamer_id"`
	ViewerID   pgtype.Text `json:"viewer_id"`
}

func (q *Queries) CreateRedemption(ctx context.Context, arg CreateRedemptionParams) (Redemption, error) {
	row := q.db.QueryRow(ctx, createRedemption, arg.MessageID, arg.StreamerID, arg.ViewerID)
	var i Redemption
	err := row.Scan(
		&i.MessageID,
		&i.StreamerID,
		&i.ViewerID,
		&i.RedeemedAt,
	)
	return i, err
}

const createReward = `-- name: CreateReward :one
INSERT INTO rewards (reward_id, streamer_id)
VALUES ($1, $2)
RETURNING reward_id, streamer_id, created_at
`

type CreateRewardParams struct {
	RewardID   string      `json:"reward_id"`
	StreamerID pgtype.Text `json:"streamer_id"`
}

func (q *Queries) CreateReward(ctx context.Context, arg CreateRewardParams) (Reward, error) {
	row := q.db.QueryRow(ctx, createReward, arg.RewardID, arg.StreamerID)
	var i Reward
	err := row.Scan(&i.RewardID, &i.StreamerID, &i.CreatedAt)
	return i, err
}

const createStreamer = `-- name: CreateStreamer :one
INSERT INTO streamers (twitch_id, username, verified, access_token, refresh_token, profile_image_url)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING twitch_id, username, verified, profile_image_url, access_token, refresh_token, created_at, updated_at
`

type CreateStreamerParams struct {
	TwitchID        string      `json:"twitch_id"`
	Username        string      `json:"username"`
	Verified        pgtype.Bool `json:"verified"`
	AccessToken     pgtype.Text `json:"access_token"`
	RefreshToken    pgtype.Text `json:"refresh_token"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
}

func (q *Queries) CreateStreamer(ctx context.Context, arg CreateStreamerParams) (Streamer, error) {
	row := q.db.QueryRow(ctx, createStreamer,
		arg.TwitchID,
		arg.Username,
		arg.Verified,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ProfileImageUrl,
	)
	var i Streamer
	err := row.Scan(
		&i.TwitchID,
		&i.Username,
		&i.Verified,
		&i.ProfileImageUrl,
		&i.AccessToken,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createViewer = `-- name: CreateViewer :one
INSERT INTO viewers (twitch_id, username, registered_in)
VALUES ($1, $2, $3)
RETURNING twitch_id, username, registered_in, created_at, updated_at
`

type CreateViewerParams struct {
	TwitchID     string      `json:"twitch_id"`
	Username     string      `json:"username"`
	RegisteredIn pgtype.Text `json:"registered_in"`
}

func (q *Queries) CreateViewer(ctx context.Context, arg CreateViewerParams) (Viewer, error) {
	row := q.db.QueryRow(ctx, createViewer, arg.TwitchID, arg.Username, arg.RegisteredIn)
	var i Viewer
	err := row.Scan(
		&i.TwitchID,
		&i.Username,
		&i.RegisteredIn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRewardsByStreamerID = `-- name: DeleteRewardsByStreamerID :exec
DELETE FROM rewards
WHERE streamer_id = $1
`

func (q *Queries) DeleteRewardsByStreamerID(ctx context.Context, streamerID pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteRewardsByStreamerID, streamerID)
	return err
}

const getAllStreamers = `-- name: GetAllStreamers :many
SELECT username, twitch_id, profile_image_url FROM streamers WHERE verified = TRUE
`

type GetAllStreamersRow struct {
	Username        string      `json:"username"`
	TwitchID        string      `json:"twitch_id"`
	ProfileImageUrl pgtype.Text `json:"profile_image_url"`
}

func (q *Queries) GetAllStreamers(ctx context.Context) ([]GetAllStreamersRow, error) {
	rows, err := q.db.Query(ctx, getAllStreamers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStreamersRow
	for rows.Next() {
		var i GetAllStreamersRow
		if err := rows.Scan(&i.Username, &i.TwitchID, &i.ProfileImageUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStreamersWithTokens = `-- name: GetAllStreamersWithTokens :many
SELECT twitch_id, username, verified, profile_image_url, access_token, refresh_token, created_at, updated_at FROM streamers
`

func (q *Queries) GetAllStreamersWithTokens(ctx context.Context) ([]Streamer, error) {
	rows, err := q.db.Query(ctx, getAllStreamersWithTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Streamer
	for rows.Next() {
		var i Streamer
		if err := rows.Scan(
			&i.TwitchID,
			&i.Username,
			&i.Verified,
			&i.ProfileImageUrl,
			&i.AccessToken,
			&i.RefreshToken,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRedemptionsWithUsernames = `-- name: GetRecentRedemptionsWithUsernames :many
SELECT
    r.message_id,
    s.username AS streamer_username, -- Get streamer username from streamers table
    v.username AS viewer_username,   -- Get viewer username from viewers table
    r.redeemed_at
FROM
    redemptions r
JOIN
    streamers s ON r.streamer_id = s.twitch_id
JOIN
    viewers v ON r.viewer_id = v.twitch_id
ORDER BY
    r.redeemed_at DESC
LIMIT $1
`

type GetRecentRedemptionsWithUsernamesRow struct {
	MessageID        string             `json:"message_id"`
	StreamerUsername string             `json:"streamer_username"`
	ViewerUsername   string             `json:"viewer_username"`
	RedeemedAt       pgtype.Timestamptz `json:"redeemed_at"`
}

func (q *Queries) GetRecentRedemptionsWithUsernames(ctx context.Context, limit int32) ([]GetRecentRedemptionsWithUsernamesRow, error) {
	rows, err := q.db.Query(ctx, getRecentRedemptionsWithUsernames, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentRedemptionsWithUsernamesRow
	for rows.Next() {
		var i GetRecentRedemptionsWithUsernamesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.StreamerUsername,
			&i.ViewerUsername,
			&i.RedeemedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRewardsByStreamer = `-- name: GetRewardsByStreamer :many
SELECT reward_id, streamer_id, created_at FROM rewards WHERE streamer_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetRewardsByStreamer(ctx context.Context, streamerID pgtype.Text) ([]Reward, error) {
	rows, err := q.db.Query(ctx, getRewardsByStreamer, streamerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reward
	for rows.Next() {
		var i Reward
		if err := rows.Scan(&i.RewardID, &i.StreamerID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamerByID = `-- name: GetStreamerByID :one
SELECT twitch_id, username, verified, profile_image_url, access_token, refresh_token, created_at, updated_at FROM streamers WHERE twitch_id = $1
`

func (q *Queries) GetStreamerByID(ctx context.Context, twitchID string) (Streamer, error) {
	row := q.db.QueryRow(ctx, getStreamerByID, twitchID)
	var i Streamer
	err := row.Scan(
		&i.TwitchID,
		&i.Username,
		&i.Verified,
		&i.ProfileImageUrl,
		&i.AccessToken,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalParticipantsCount = `-- name: GetTotalParticipantsCount :one
SELECT COUNT(*) AS total_participants
FROM viewers
`

func (q *Queries) GetTotalParticipantsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalParticipantsCount)
	var total_participants int64
	err := row.Scan(&total_participants)
	return total_participants, err
}

const getTotalRedemptionsCount = `-- name: GetTotalRedemptionsCount :one
SELECT COUNT(*) AS total_redemptions
FROM redemptions
`

func (q *Queries) GetTotalRedemptionsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalRedemptionsCount)
	var total_redemptions int64
	err := row.Scan(&total_redemptions)
	return total_redemptions, err
}

const getViewerByID = `-- name: GetViewerByID :one
SELECT twitch_id, username, registered_in, created_at, updated_at FROM viewers WHERE twitch_id = $1
`

func (q *Queries) GetViewerByID(ctx context.Context, twitchID string) (Viewer, error) {
	row := q.db.QueryRow(ctx, getViewerByID, twitchID)
	var i Viewer
	err := row.Scan(
		&i.TwitchID,
		&i.Username,
		&i.RegisteredIn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getViewerLeaderboard = `-- name: GetViewerLeaderboard :many
SELECT
    v.username, -- Retrieve the username from the viewers table
    COUNT(r.*) AS total_redemptions
FROM
    redemptions r
JOIN
    viewers v ON r.viewer_id = v.twitch_id -- Join the tables based on viewer_id
GROUP BY
    r.viewer_id, v.username -- Group by both viewer_id and username
ORDER BY
    total_redemptions DESC
`

type GetViewerLeaderboardRow struct {
	Username         string `json:"username"`
	TotalRedemptions int64  `json:"total_redemptions"`
}

func (q *Queries) GetViewerLeaderboard(ctx context.Context) ([]GetViewerLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getViewerLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetViewerLeaderboardRow
	for rows.Next() {
		var i GetViewerLeaderboardRow
		if err := rows.Scan(&i.Username, &i.TotalRedemptions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStreamerTokens = `-- name: UpdateStreamerTokens :one
UPDATE streamers 
SET access_token = $2, 
    refresh_token = $3
WHERE twitch_id = $1
RETURNING twitch_id, username, verified, profile_image_url, access_token, refresh_token, created_at, updated_at
`

type UpdateStreamerTokensParams struct {
	TwitchID     string      `json:"twitch_id"`
	AccessToken  pgtype.Text `json:"access_token"`
	RefreshToken pgtype.Text `json:"refresh_token"`
}

func (q *Queries) UpdateStreamerTokens(ctx context.Context, arg UpdateStreamerTokensParams) (Streamer, error) {
	row := q.db.QueryRow(ctx, updateStreamerTokens, arg.TwitchID, arg.AccessToken, arg.RefreshToken)
	var i Streamer
	err := row.Scan(
		&i.TwitchID,
		&i.Username,
		&i.Verified,
		&i.ProfileImageUrl,
		&i.AccessToken,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
